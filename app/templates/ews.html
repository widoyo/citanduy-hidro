<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EWS Hidrologi Citanduy</title>
    <link rel="icon" type="image/x-icon" href="/static/img/pupr.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #map {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0; left: 0;
        }
        /* Styling untuk container sidebar, ini sekarang akan berada di dalam div yang dibuat oleh Leaflet */
        .leaflet-control-sidebar { /* Ini adalah kelas yang akan kita gunakan untuk container sidebar kita */
            /* Kita tidak lagi perlu position: absolute di sini, karena Leaflet yang mengaturnya */
            width: 280px;
            max-height: calc(100vh - 40px); /* Batasi tinggi container agar tidak melebihi viewport */
            overflow-y: auto; /* Aktifkan scroll jika konten box terlalu banyak */
            background-color: rgba(255, 255, 255, 0.5); /* Latar belakang sedikit transparan */
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: flex; /* Gunakan flexbox untuk menata box-box di dalamnya secara vertikal */
            flex-direction: column;
            gap: 10px; /* Jarak antar box */
            box-sizing: border-box; /* Pastikan padding tidak menambah lebar/tinggi */
        }

        .box {
            background-color: rgba(240, 240, 240, 0.7);
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .box-header {
            padding: 10px;
            background-color: rgba(230, 230, 230, 0.95);
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .box-header:hover {
            background-color: rgba(220, 220, 220, 0.95);
        }

        .toggle-icon {
            font-size: 1.2em;
            transition: transform 0.3s ease;
        }

        .box-content {
            max-height: 0;
            overflow-y: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            padding: 0 15px;
            flex: 1;
            min-height: 0;
        }

        .box:not(.collapsed) .box-content {
            max-height: 500px;
            padding: 10px 15px;
            overflow-y: auto;
        }

        .box.collapsed .toggle-icon {
            transform: rotate(0deg);
        }

        .box:not(.collapsed) .toggle-icon {
            transform: rotate(45deg);
        }
        
        /* Override Leaflet's default padding for controls if needed */
        .leaflet-right .leaflet-control {
             margin-right: 10px; /* Sesuaikan padding agar lebih pas dengan 20px dari tepi */
             margin-top: 10px; /* Sesuaikan padding agar lebih pas dengan 20px dari tepi */
        }
        .logo-container {
            /* Terapkan Flexbox pada kontainer div */
            display: flex;
            /* Sejajarkan item secara vertikal di tengah */
            align-items: center;
            justify-content: space-between;
            /* Beri sedikit jarak antar gambar dan teks */
            gap: 20px; /* Jarak antara elemen flex */

            /* Tambahan styling agar lebih terlihat */
            padding: 5px;
        }

        .logo-text {
            font-size: 20pt;
            font-weight: lighter;
            letter-spacing: 0.4rem;
            color: #d00;
            /*text-shadow: 0vw 0vw 0.5vw rgba(192, 192, 192, 0.9);*/
            line-height: initial;
            /* vertical-align tidak lagi diperlukan karena Flexbox yang mengatur */
        }
        .time-container {
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
            color: #333;
        }
        
        .hour-text {
            font-size: xx-large;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="/static/js/adm.js"></script>
    <script src="/static/js/sungai.js"></script>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([0, 0], 2); // Centered at lat 0, lng 0, zoom 2
        L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1Ijoid2lkb3lvIiwiYSI6ImNsNG1kcGFucTFicWUza21uMmJudTRkd3AifQ.-AhfUIYwXDOIwfD6nVFxxw', {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
                '<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
                'Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
                    id: 'mapbox/streets-v11'
        }).addTo(map);

        // --- Daftar Layer GeoJSON yang akan dimuat ---
        const geoJsonLayers = {}; // Objek untuk menyimpan referensi layer setelah dimuat

        // Definisi sungai yang akan ditampilkan
        const sungaiToShow = [
            { id: 'citanduy', label: 'Citanduy' },
            { id: 'cijolang', label: 'Cijolang' },
            { id: 'ciseel', label: 'Ciseel' },
            { id: 'cibeureum', label: 'Cibeureum' },
            { id: 'cijalu', label: 'Cijalu' },
            { id: 'cikidang', label: 'Cikidang' },
            { id: 'cimuntur', label: 'Cimuntur' },
        ];

        // load geojson dari sungai.js sesuai sungaiToShow
        ['s_orde_1', 's_orde_2', 's_orde_3', 's_orde_4'].forEach(orde => {
            if (window[orde]) {
                console.log(`Filtering ${orde} to show only selected rivers`);
                window[orde].features = window[orde].features.filter(f => sungaiToShow.some(s => s.id === f.properties.NAMOBJ?.toLowerCase()));
                console.log(`Loaded ${window[orde].features.length} features for ${orde}`);
                window[orde].features.forEach(f => {
                    // Hanya tampilkan sungai yang ada di sungaiToShow
                    let weight = 1;
                    if (orde[orde.length - 1] === '1') {
                        weight = 3;
                    }
                    const layer = L.geoJSON(f, {
                        style: {color: '#1f56b5', weight: weight},
                        onEachFeature: function(feature, layer) {
                            if (feature.properties && feature.properties.NAMOBJ) {
                                layer.bindTooltip(feature.properties.NAMOBJ, {sticky: true});
                            }
                        }
                    });
                    geoJsonLayers[f.properties.NAMOBJ.toLowerCase()] = layer; // Simpan referensi layer
                    layer.addTo(map);
                    console.log(`Loaded river: ${f.properties.NAMOBJ}`);
                });
            }
        });
        // Definisi semua layer yang ingin Anda tampilkan
        const layerDefinitions = [
            {
                id: 'administrasi',
                label: 'Wilayah Administrasi',
                defaultVisible: false,
                style: function(feature) {
                    return {
                        color: "#888800",
                        weight: 1,
                        fillOpacity: 0,
                        opacity: 1
                    };
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties && feature.properties.NAMOBJ) {
                        layer.bindTooltip(feature.properties.NAMOBJ, {sticky: true});
                    }
                },
                // Layer ini akan dimuat dari objek adm_js yang sudah ada di window
                loadFromObject: true,
                path: null // Tambahkan path: null agar tidak di-fetch
            },
            {
                id: 'wscitanduy',
                path: '/static/js/citanduy.json',
                label: 'DAS di WS Citanduy',
                defaultVisible: true,
                style: function(feature) {
                    return {
                        color: "#dd0000",
                        weight: 1,
                        fillOpacity: feature.properties?.["fill-opacity"] || 0,
                        opacity: feature.properties?.["stroke-opacity"] || 1
                    };
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties && feature.properties.NAMA_DAS) {
                        layer.bindTooltip(feature.properties.NAMA_DAS, {sticky: false});
                    }
                }
            },
            {
                id: 'faultyDevice',
                path: '/ews?device=1',
                label: `Faulty Device <span id="faulty-badge" style="background:#d00; color:#fff; border-radius:8px; font-size:10px; padding:2px 4px; vertical-align:middle;">0</span>`,
                defaultVisible: false,
                type: 'json-list', // Tipe data yang diharapkan
                style: function(feature) {
                    return {
                        color: "#FF0000",
                        fillColor: "#FF0000",
                        weight: 2,
                        opacity: 0.8,
                        fillOpacity: 0.5,
                        radius: 6
                    };
                },
                filter: function(feature) {
                    if (!feature || !feature.properties || !feature.properties.latest_sampling) return false;
                    const samplingTime = new Date(feature.properties.latest_sampling.replace(' ', 'T'));
                    const now = new Date();
                    const diffMs = now - samplingTime;
                    const diffHours = diffMs / (1000 * 60 * 60);
                    return diffHours > 2;
                }, // Filter untuk layer ini
                pointToLayer: (feature, latlng) => {
                    return L.circleMarker(latlng, layerDefinitions.find(def => def.id === 'faultyDevice').style(feature));
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties && feature.properties.nama) {
                        layer.bindPopup(`
                            <div style="padding:4px; min-width:220px;">
                                <h4 style="margin:0 0 8px 0; color:#d00;">Faulty Device</h4>
                                <div style="font-weight:bold; margin-bottom:6px;">${feature.properties.nama}</div>
                                <div style="font-size:0.95em; color:#555;">
                                    <span>Last Sampling:</span><br>
                                    <span style="font-weight:bold;">${feature.properties.latest_sampling}</span>
                                </div>
                                <div style="margin-top:8px; color:#d00; font-size:1.1em;">
                                    Offline for <span id="offline-duration-${feature.properties.id || feature.properties.nama.replace(/\s/g,'')}"></span>
                                </div>
                            </div>
                        `, {autoPan: true});

                        // Calculate and set offline duration after popup opens
                        layer.on('popupopen', function(e) {
                            const samplingTime = new Date(feature.properties.latest_sampling.replace(' ', 'T'));
                            const now = new Date();
                            const diffMs = now - samplingTime;
                            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                            const diffMinutes = Math.floor((diffMs / (1000 * 60)) % 60);
                            let durationText = '';
                            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                            if (diffDays > 365) {
                                durationText = 'more than a year';
                            } else if (diffDays > 180) {
                                durationText = 'more than 6 months';
                            } else if (diffDays > 30) {
                                durationText = 'more than 1 month';
                            } else if (diffDays > 0) {
                                durationText = `${diffDays} day${diffDays > 1 ? 's' : ''}, ${diffHours % 24} hour${(diffHours % 24) !== 1 ? 's' : ''}`;
                            } else if (diffHours > 0) {
                                durationText = `${diffHours} hour${diffHours > 1 ? 's' : ''}`;
                            } else {
                                durationText = `${diffMinutes} min`;
                            }
                            const elId = `offline-duration-${feature.properties.id || feature.properties.nama.replace(/\s/g,'')}`;
                            const el = document.getElementById(elId);
                            if (el) el.textContent = durationText;
                        });
                    }
                }
            },
            {
                id: 'rainSensor',
                path: '/api/pos', // Path ke API tunggal
                label: 'Pos Curah Hujan',
                type: 'json-list', // Tipe data yang diharapkan
                defaultVisible: false,
                filter: function(feature) { return feature && feature.properties && (feature.properties.tipe === '1' || feature.properties.tipe === '3'); }, // Filter untuk layer ini
                style: function(feature) {
                    return {
                        color: "#0080FF",
                        fillColor: "#0080FF",
                        weight: 2,
                        opacity: 0.8,
                        fillOpacity: 0.6,
                        radius: 6
                    };
                },
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, layerDefinitions.find(def => def.id === 'rainSensor').style(feature));
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties && feature.properties.nama) {
                        layer.bindPopup("Rain Sensor: " + feature.properties.nama + " :" + feature.properties.tipe);
                    }
                }
            },
            {
                id: 'waterLevelSensor',
                path: '/api/pos', // Path ke API tunggal
                label: 'Pos Duga Air',
                type: 'json-list',
                defaultVisible: false,
                filter: function(feature) {
                    return feature && feature.properties && feature.properties.tipe === '2'; 
                }, // Filter untuk layer ini
                style: function(feature) {
                    return {
                        color: "#00BFFF",
                        fillColor: "#00BFFF",
                        weight: 2,
                        opacity: 0.8,
                        fillOpacity: 0.6,
                        radius: 6
                    };
                },
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, layerDefinitions.find(def => def.id === 'waterLevelSensor').style(feature));
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties && feature.properties.nama) {
                        layer.bindPopup("Water Level Sensor: " + feature.properties.location + " :" + feature.properties.tipe);
                    }
                }
            },
        ];

        // Objek untuk melacak URL yang sudah di-fetch agar tidak fetch berkali-kali
        const fetchedGeoJSONData = {};

        /**
         * Mengkonversi daftar objek JSON biasa menjadi GeoJSON FeatureCollection.
         * Asumsi: Setiap objek memiliki properti 'll' dalam format "latitude,longitude".
         */
        function convertJsonListToGeoJSON(jsonList) {
            const features = jsonList.map(item => {
                //console.log(item);
                if (!item && !item.ll || typeof item.ll !== 'string' || !item.ll.includes(',')) {
                    // Skip this item if ll is missing or invalid
                    return null;
                }
                const [lat, lon] = item.ll.split(',').map(Number); // Pisahkan dan konversi ke angka
                if (isNaN(lat) || isNaN(lon)) {
                    // Skip this item if lat/lon are not valid numbers
                    return null;
                }
                return {
                    type: "Feature",
                    properties: { ...item }, // Salin semua properti asli
                    geometry: {
                        type: "Point",
                        coordinates: [lon, lat] // GeoJSON format: [longitude, latitude]
                    }
                };
            }).filter(feature => feature !== null); // Hapus fitur yang null (invalid)

            return {
                type: "FeatureCollection",
                features: features
            };
        }

        // --- Fungsi untuk memuat dan memproses setiap layer ---
        async function loadGeoJsonLayer(layerDef) {
            try {
                let geojson;
                let processedGeoJSON;

                // Khusus untuk layer administrasi, gunakan objek adm_js dari window
                if (layerDef.loadFromObject && window.administratif) {
                    geojson = window.administratif;
                    processedGeoJSON = geojson;
                } else {
                    // Cek apakah data untuk path ini sudah di-fetch
                    if (fetchedGeoJSONData[layerDef.path]) {
                        geojson = fetchedGeoJSONData[layerDef.path];
                    } else {
                        // Jika belum, fetch data dan simpan
                        const res = await fetch(layerDef.path);
                        if (!res.ok) {
                            throw new Error(`Failed to load ${layerDef.path}: ${res.statusText}`);
                        }
                        const rawData = await res.json();
                        fetchedGeoJSONData[layerDef.path] = rawData; // Simpan data yang di-fetch
                        geojson = rawData;
                    }
                    // Jika ini adalah JSON list, konversi ke GeoJSON FeatureCollection
                    if (layerDef.type === 'json-list') {
                        processedGeoJSON = convertJsonListToGeoJSON(geojson);
                    } else {
                        // Jika sudah GeoJSON, langsung gunakan
                        processedGeoJSON = geojson;
                    }
                }
                //console.log(`Loading GeoJSON layer: ${layerDef.id} from ${layerDef.path}`);
                //console.log(processedGeoJSON);
                // Jika ada filter, buat objek GeoJSON baru yang difilter
                let finalGeoJSON = processedGeoJSON;
                if (layerDef.filter && processedGeoJSON.features) {
                    finalGeoJSON = {
                        ...geojson, // Copy properti lain dari geojson asli
                        features: processedGeoJSON.features.filter(layerDef.filter)
                    };
                }

                // Buat layer Leaflet dari GeoJSON yang sudah difilter
                if (finalGeoJSON && finalGeoJSON.features && finalGeoJSON.features.length > 0) {
                    const layer = L.geoJSON(finalGeoJSON, {
                        style: layerDef.style,
                        onEachFeature: layerDef.onEachFeature,
                        pointToLayer: layerDef.pointToLayer
                    });
                    geoJsonLayers[layerDef.id] = layer; // Simpan referensi layer

                    // Jika layer seharusnya terlihat secara default, tambahkan ke peta
                    if (layerDef.defaultVisible) {
                        if (layerDef.id === 'wscitanduy') {
                            layer.addTo(map);
                            layer.bringToBack();
                        } else {
                            layer.addTo(map);
                        }
                    }

                    // Opsional: Atur batas peta ke layer GeoJSON pertama yang dimuat, atau semua layer
                    if (layerDef.id === 'wscitanduy') { // Atau layer lain yang paling penting
                        map.fitBounds(layer.getBounds());
                    }

                    // Tambahkan badge faulty-badge jika ada
                    if (layerDef.id === 'faultyDevice') {
                        const el = document.getElementById('faulty-badge');
                        if (el) {
                            el.textContent = finalGeoJSON.features.length; // Update badge dengan jumlah fitur
                            if (finalGeoJSON.features.length > 0) {
                                el.style.display = 'inline'; // Tampilkan badge jika ada fitur 
                            } else {
                                el.style.display = 'none'; // Sembunyikan badge jika tidak ada fitur
                            }
                        }
                    }
                } else {
                    console.warn(`Layer ${layerDef.id} tidak memiliki fitur yang valid dan tidak akan ditambahkan ke peta.`);
                }

            } catch (error) {
                console.error("Error loading GeoJSON layer:", layerDef.id, error);
            }
        }

        // Muat semua layer GeoJSON yang didefinisikan
        layerDefinitions.forEach(loadGeoJsonLayer);
        window.simulasi = false;

        function createSensorMarker(latlng, sensorId, badgeStatus, options = {}) {
            // Default options
            const defaults = {
                size: 16,               // Size of the square in pixels
                color: '#2c3e50',       // Square border color
                fillColor: '#3498db',    // Square fill color
                fillOpacity: 0.8,
                textColor: '#ffffff',    // Center number color
                badgeSize: 0,           // Badge circle size
                badgeStatus: 'normal',   // 'normal', 'warning', or 'alert'
                blink: false             // Enable blinking animation
            };
            
            const config = { ...defaults, ...options, badgeStatus };
            
            // Badge color mapping
            const badgeColors = {
                normal: '#4CAF50',  // Green
                warning: '#FFC107', // Yellow
                alert: '#F44336'    // Red
            };
            
            const badgeColor = badgeColors[config.badgeStatus] || '#000000';
            
            // Create blinking class if needed
            const blinkClass = config.blink ? 'blinking-badge' : '';
            
            return L.marker(latlng, {
                icon: L.divIcon({
                    className: 'sensor-marker',
                    html: `
                        <div style="
                            position: relative;
                            width: ${config.size}px;
                            height: ${config.size}px;
                            background: ${config.fillColor};
                            border: 2px solid ${config.color};
                            border-radius: 3px;
                            opacity: ${config.fillOpacity};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: ${config.textColor};
                            font-weight: bold;
                            font-size: ${Math.round(config.size * 0.6)}px;
                        ">
                            ${sensorId}
                            <div class="${blinkClass}" style="
                                position: absolute;
                                top: -${config.badgeSize/3}px;
                                right: -${config.badgeSize/3}px;
                                width: ${config.badgeSize}px;
                                height: ${config.badgeSize}px;
                                background: ${badgeColor};
                                border-radius: 50%;
                                border: 1px solid white;
                            "></div>
                        </div>
                    `,
                    iconSize: [config.size, config.size],
                    iconAnchor: [config.size/2, config.size/2]
                })
            });
        }

        // --- Bagian Baru: Membuat Custom Leaflet Control ---
        var SidebarControl = L.Control.extend({
            options: {
                position: 'topright' // Posisi kontrol di peta
            },
            customDate: new Date(), // Variabel untuk menyimpan tanggal khusus
            isSimulasi: false,
            isSimul: function() {
                console.log('Simulasi status:', this.simulasi);
                return this.simulasi === true;
            },
            updateScreen: function() {
                // Update screen logic here
                console.log('Updating screen...');
                this.updateRain();
                this.updateWlevel();
            },
            updateRain: function() {
                // Update rain data logic here
                console.log('Updating rain data...');
                let el = document.getElementById('rain-badge');
                if (el) {
                    el.style.backgroundColor = '#009900'; // Set background color to green
                }

                let el_pch_list = document.getElementById('pch-heavy-list');
                
                // fetch /api/rain and update the map
                fetch('/ews?rain=1')
                    .then(response => response.json())
                    .then(data => {
                        // Clear existing rain markers
                        // Remove existing rain circle markers (by checking for circleMarker type and a custom property)
                        map.eachLayer(layer => {
                            if (layer instanceof L.CircleMarker && layer.options && layer.options.color === '#0074D9') {
                                map.removeLayer(layer);
                            }
                        });
                        if (data.length > 0) {
                            el.textContent = data.length; // Update badge with the number of rain markers
                            el.style.display = 'inline'; // Show the element if there are markers
                            el.style.backgroundColor = '#cc0000';
                        } else {
                            el.style.backgroundColor = '#009900';
                            el_pch_list.textContent = 'Kosong';
                        }
    
                        let ol = document.createElement('ol');
                        ol.style.paddingInlineStart = '20px';
                        ol.style.marginTop = '0px';
                        // Add new rain markers to the map
                        data.forEach(item => {
                            let li = document.createElement('li');
                            li.textContent = item.pos.nama;
                            ol.appendChild(li);
                            const [lat, lon] = item.pos.latlon.split(',').map(Number);
                            if (isNaN(lat) || isNaN(lon)) {
                                // Skip this item if lat/lon are not valid numbers
                                return;
                            }
                            const marker = createSensorMarker([lat, lon], item.pos.id).addTo(map);
                            /*
                            const marker = L.circleMarker([lat, lon], {
                                radius: 6,
                                color: '#0074D9',
                                fillColor: '#0074D9',
                                fillOpacity: 0.8,
                                weight: 2
                            })
                            .addTo(map);
                            */
                            marker.bindPopup(`
                            <div style="padding:4px; min-width:220px;">
                                <h4 style="margin:0 0 8px 0; color:#FF851B;">Siaga Hujan</h4>
                                <div style="font-weight:bold; margin-bottom:6px;">${item.pos.nama} <span style="margin: 4px 0 0;font-weight:500;color:#888">+${item.pos.elevasi} <span style="font-size: 11px;font-weight:500;letter-spacing:0.1rem;color:#888">MDPL</span></div>
                                <div style="font-size:11px; letter-spacing: 0.1em;color:#888;">CURAH HUJAN
                                    <div style="font-size: 5em;color:#444">${item.rain} <span style="font-size:11px;color:#888">mm</span>selama ${item.total_seconds}</div>
                                </div>
                                <div style="font-size:0.95em; color:#555;">
                                    <span>Last Sampling:</span><br>
                                    <span style="font-weight:bold;">${item.sampling}</span>
                                </div>
                            </div>
                        `, {autoPan: true});
                        });
                        el_pch_list.innerHTML = '';
                        el_pch_list.appendChild(ol);
                    })
                    .catch(error => {
                        console.error('Error fetching rain data:', error);
                    });
            },
            updateWlevel: function() {
                // Update water level data logic here
                console.log('Updating water level data...');
                let el = document.getElementById('wlevel-badge');
                if (el) {
                    el.style.backgroundColor = '#009900'; // Set background color to green
                }
                let pda_list = document.getElementById('pda-overflow-list');
                
                // fetch /api/wlevel and update the map
                fetch('/ews?wlevel=1')
                    .then(response => response.json())
                    .then(data => {
                        // Clear existing water level markers
                        // Remove existing water level circle markers (by checking for circleMarker type and a custom property)
                        map.eachLayer(layer => {
                            if (layer instanceof L.CircleMarker && layer.options && layer.options.color === '#FF851B') {
                                map.removeLayer(layer);
                            }
                        });
                        el.textContent = data.length;
                        if (data.length > 0) {
                            el.style.display = 'inline'; // Show the element if there are markers
                            el.style.backgroundColor = '#cc0000';
                        }

                        // Add new water level markers to the map
                        data.forEach(item => {
                            const [lat, lon] = item.pos.latlon.split(',').map(Number);
                            if (isNaN(lat) || isNaN(lon)) {
                                // Skip this item if lat/lon are not valid numbers
                                return;
                            }
                            const marker = L.circleMarker([lat, lon], {
                                radius: 6,
                                color: '#FF851B',
                                fillColor: '#FF851B',
                                fillOpacity: 0.8,
                                weight: 2
                            })
                            .addTo(map);
                            marker.bindPopup(`
                            <div style="padding:4px; min-width:220px;">
                                <h4 style="margin:0 0 8px 0; color:#FF851B;">Siaga Muka Air</h4>
                                <div style="font-weight:bold; margin-bottom:6px;">${item.pos.nama}</div>
                                <div style="font-size:0.95em; color:#555;">
                                    <span>Last Sampling:</span><br>
                                    <span style="font-weight:bold;">${item.sampling}</span>
                                </div>
                            </div>
                        `, {autoPan: true});
                        });
                    })
                    .catch(error => {
                        console.error('Error fetching water level data:', error);
                    });
            },
            onAdd: function (map) {
                // Buat elemen div yang akan menjadi container sidebar
                var container = L.DomUtil.create('div', 'leaflet-control-sidebar');
                // Beri event handler agar Leaflet tidak menangani scroll atau klik di dalam kontrol
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.disableScrollPropagation(container);

                // Expose isSimul to global scope so the button can call it
                window.isSimul = this.isSimul.bind(this);

                // Konten HTML untuk sidebar
                let layerBoxContent = '';
                layerDefinitions.forEach(def => {
                    layerBoxContent += `
                        <div class="checkbox-item">
                            <input type="checkbox" id="${def.id}LayerToggle" ${def.defaultVisible ? 'checked' : ''}>
                            <label for="${def.id}LayerToggle">${def.label}</label>
                        </div>
                    `;
                });
                // Tambahkan checkbox untuk sungai yang ingin ditampilkan
                layerBoxContent += '<h4>Sungai</h4>';
                sungaiToShow.forEach(s => {
                    layerBoxContent += `
                        <div class="checkbox-item">
                            <input type="checkbox" id="${s.id}LayerToggle" checked>
                            <label for="${s.id}LayerToggle">${s.label}</label>
                        </div>
                    `;
                });

                // Isi container dengan struktur HTML box-box Anda
                container.innerHTML = `
                    <div class="logo-container">
                        <div><div class="logo-text">EWS</div>
                            <div style="font-size:9pt;color:black;text-shadow: none !important;">Hidrometeorologi</div>
                        </div>
                        <div class="time-container"><span class="date-text">23 Juli<br>2025</span><span class="hour-text">16:04</span></div>
                    </div>
                        <div class="box">
                        <h3 class="box-header">
                            Curah Hujan 
                            <span>
                                <span id="rain-badge" style="margin-right: 10px; background:#090; color:#fff; border-radius:8px; font-size:10px; padding:2px 4px; vertical-align:middle;">0</span>
                                <span class="toggle-icon">+</span>
                            </span>
                        </h3>
                        <div class="box-content" style="overflow-y: auto">
                            <div id="pch-heavy-list">
                                <p>Kosong</p>
                            </div>
                        </div>
                    </div>

                    <div class="box">
                        <h3 class="box-header">
                            Tinggi Muka Air
                            <span>
                                <span id="wlevel-badge" style="margin-right: 10px; background:#090; color:#fff; border-radius:8px; font-size:10px; padding:2px 4px; vertical-align:middle;">0</span>
                                <span class="toggle-icon">+</span>
                            </span>
                        </h3>
                        <div class="box-content" style="overflow-y: auto;">
                            <div id="pda-overflow-list">
                                <p>Kosong</p>
                            </div>
                        </div>
                    </div>

                    <div class="box">
                        <h3 class="box-header">Properti <span class="toggle-icon">+</span></h3>
                        <div class="box-content layer-toggles" style="overflow-y: auto;">
                        ${layerBoxContent}
                        </div>
                    </div>

                    <div class="box">
                        <h3 class="box-header">Legenda <span class="toggle-icon">+</span></h3>
                        <div class="box-content layer-toggles">
                            <ul style="padding-inline-start: 20px;margin-top: 0px;">
                                <li>Pos Curah Hujan</li>
                                <li>Pos Duga Air</li>
                                <li>Pos Klimatologi</li>
                                <li>Batas Das / Wilayah Sungai</li>
                                <li>Batas Wilayah Adminsitratif</li>
                            </ul>
                        </div>
                    </div>

                    <div class="box">
                        <h3 class="box-header">About... <span class="toggle-icon">+</span></h3>
                        <div class="box-content">
                            <p>Peringatan Dini Hujan dan Tinggi Muka Air</p>
                            <p>Hujan kategori lebat sejam lalu</p>
                            <p>Tinggi muka air yang melebihi batas Siaga Kuning</p>
                            <p>Anda juga dapat berlangganan Telegram </p>
                        </div>
                    </div>
                    `;

                // Setelah container dan isinya dibuat, inisialisasi fungsionalitas collapse
                // Perhatikan bahwa kita harus mencari elemen di dalam 'container' yang baru dibuat
                setTimeout(() => { // Menggunakan setTimeout kecil untuk memastikan DOM sudah dirender
                    container.querySelectorAll('.box-header').forEach(header => {
                        header.addEventListener('click', () => {
                            const box = header.closest('.box');
                            const toggleIcon = header.querySelector('.toggle-icon');
                            box.classList.toggle('collapsed');
                        });
                    });

                    // Inisialisasi semua box sebagai collapsed secara default (opsional)
                    container.querySelectorAll('.box').forEach(box => {
                        box.classList.add('collapsed');
                        box.querySelector('.toggle-icon').textContent = '+';
                    });

                    // --- Fungsionalitas Checkbox untuk Semua Layer ---
                    // Dapatkan kontainer untuk toggle layer
                    const layerTogglesContainer = container.querySelector('.layer-toggles');
                    if (layerTogglesContainer) {
                        // Iterasi semua checkbox di dalamnya
                        layerTogglesContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                            const layerId = checkbox.id.replace('LayerToggle', ''); // Dapatkan ID layer dari ID checkbox

                            checkbox.addEventListener('change', function() {
                                const layer = geoJsonLayers[layerId]; // Ambil referensi layer dari objek geoJsonLayers
                                if (layer) { // Pastikan layer sudah dimuat
                                    if (this.checked) {
                                        if (!map.hasLayer(layer)) {
                                            layer.addTo(map);
                                        }
                                    } else {
                                        if (map.hasLayer(layer)) {
                                            map.removeLayer(layer);
                                        }
                                    }
                                } else {
                                    console.warn(`Layer with ID ${layerId} not yet loaded or does not exist.`);
                                }
                            });
                        });
                    }

                    const dateTextElement = document.querySelector('.date-text');
                    const hourTextElement = document.querySelector('.hour-text');

                    let showColon = true; // Status untuk berkedip

                    // Fungsi untuk mengupdate waktu
                    const updateDateTime = (date = this.customDate) => {
                        const optionsDayMonth = { day: 'numeric', month: 'short' }; // 'short' untuk singkatan bulan (Jul)
                        const optionsYear = { year: 'numeric' };

                        // Ambil bagian tanggal (dd mmm) dan tahun (yyyy) secara terpisah
                        const dayMonth = date.toLocaleDateString('id-ID', optionsDayMonth);
                        const year = date.toLocaleDateString('id-ID', optionsYear);

                        // Gabungkan dengan <br> dan gunakan innerHTML
                        dateTextElement.innerHTML = `${dayMonth}<br>${year}`;

                        // Format jam: '16:04'
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');

                        // Kontrol titik dua berkedip
                        const colon = showColon ? ':' : ' '; // Tampilkan ':' atau ' ' (spasi)
                        hourTextElement.textContent = `${hours}${colon}${minutes}`;

                        showColon = !showColon; // Balik status untuk detik berikutnya

                        // this,customDate +=  500ms; // Tambahkan 500ms untuk update berikutnya
                        this.customDate = new Date(date.getTime() + 500);
                        
                        // Jika menit dalam kelipatan 5, jalankan updateScreen
                        if (date.getMinutes() % 5 === 0 && date.getSeconds() === 0) {
                            this.updateScreen();
                        }
                    }

                    // --- Inisialisasi dan Pembaruan Otomatis ---

                    // Panggil pertama kali untuk menampilkan waktu segera
                    updateDateTime();

                    // Panggil updateScreen saat halaman dimuat
                    this.updateScreen();

                    // Perbarui setiap 500ms (setengah detik) untuk efek berkedip titik dua
                    setInterval(updateDateTime, 500);

                    // --- Fungsi untuk Mengatur Waktu Secara Manual (Opsional) ---
                    // Anda bisa memanggil fungsi ini dari console browser atau dari event lain
                    const setCustomDateTime = function(year, month, day, hours, minutes, seconds = 0) {
                        this.customDate = new Date(year, month - 1, day, hours, minutes, seconds); // month-1 karena bulan di JS 0-indexed

                        updateDateTime(this.customDate);
                        window.simulasi = true; // Set simulasi ke true
                        // Hentikan interval otomatis jika ingin waktu manual tetap
                        clearInterval(updateDateTime); // Ini akan menghentikan pembaruan otomatis
                        console.log(`Waktu diatur secara manual ke: ${this.customDate.toLocaleString('id-ID')}`);
                    }

                    // Contoh cara memanggil secara manual (bisa dihapus setelah pengujian):
                    // setCustomDateTime(2026, 1, 15, 9, 30); // Contoh: 15 Januari 2026, 09:30

                }, 0); // Timeout 0ms akan menunda eksekusi hingga event loop berikutnya

                return container; // Mengembalikan elemen container yang akan ditambahkan ke peta
            },

            onRemove: function (map) {
                // Tidak ada yang perlu dilakukan di sini untuk contoh sederhana ini
            }
        });

        // Tambahkan kontrol kustom ke peta
        new SidebarControl().addTo(map);


        // --- Genangan GeoJSON Layer logic ---
        const data_genangan = [
            {
                "nama": "Bendung Cilopadang",
                "fname": "pda_bendung_cilopadang.geojson",
            },
            {
                "nama": "Bendung Cijalu",
                "fname": "pda_bendung_cijalu.geojson",
            },
            {
                "nama": "PDA Cikidang",
                "fname": "pda_cikidang.geojson",
            },
            {
                "nama": "PDA Pitulasi",
                "fname": "pda_pitulasi.geojson",
            },
            {
                "nama": "PDA Cukangleuleus",
                "fname": "pda_cukangleuleus.geojson",
            },
            {
                "nama": "PDA Stinggil",
                "fname": "pda_stinggil.geojson",
            },
            {
                "nama": "PDA Sukaharja",
                "fname": "pda_sukaharja.geojson",
            }
        ];

    </script>
</body>
</html>