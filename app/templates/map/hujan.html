{% extends "base.html" %}
{% block content %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rainfall IDW</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { 
      width: 100vw; 
      height: calc(100vh - 60px); 
      position: fixed;
      top: 60px;
      left: 0;
      z-index: 1;
    }
    .legend { 
      background: white;
      padding: 10px;
      border-radius: 6px;
      line-height: 1.4;
      position: relative;
      z-index: 1000;
    }
    .legend div { display: flex; align-items: center; gap: 6px; }
    .colorbox { width: 14px; height: 14px; border-radius: 3px; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ===== MAP INIT =====
    const map = L.map('map').setView([-7.3, 108.5], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    // ===== GLOBAL STATE =====
    let rainMin = 0;
    let rainMax = 100;

    // ===== COLOR FUNCTIONS =====
    function getColor(v) {
      if (v === null || isNaN(v) || v < 0.5) return "rgba(0,0,0,0)"; // No color below 0.5mm
      
      // Rainfall categories with colors:
      // 0.5-20: Hujan Ringan (Light Rain) - Light Green to Green
      // 20-50: Hujan Sedang (Moderate Rain) - Green to Yellow
      // 50-100: Hujan Lebat (Heavy Rain) - Yellow to Orange
      // 100-150: Hujan Sangat Lebat (Very Heavy Rain) - Orange to Dark Orange
      // >150: Hujan Ekstrim (Extreme Rain) - Red
      
      if (v < 20) {
        // Light Rain: Light Green -> Green
        const t = (v - 0.5) / (20 - 0.5);
        const r = Math.round(144 * (1 - t * 0.5)); // 144 -> 72
        const g = Math.round(238 - 48 * t);         // 238 -> 190
        const b = Math.round(144 * (1 - t));        // 144 -> 0
        return `rgb(${r},${g},${b})`;
      } else if (v < 50) {
        // Moderate Rain: Green -> Yellow
        const t = (v - 20) / (50 - 20);
        const r = Math.round(72 + 183 * t);  // 72 -> 255
        const g = Math.round(190 + 65 * t);  // 190 -> 255
        const b = 0;
        return `rgb(${r},${g},${b})`;
      } else if (v < 100) {
        // Heavy Rain: Yellow -> Orange
        const t = (v - 50) / (100 - 50);
        const r = 255;
        const g = Math.round(255 - 90 * t);  // 255 -> 165
        const b = 0;
        return `rgb(${r},${g},${b})`;
      } else if (v < 150) {
        // Very Heavy Rain: Orange -> Dark Orange
        const t = (v - 100) / (150 - 100);
        const r = 255;
        const g = Math.round(165 - 65 * t);  // 165 -> 100
        const b = 0;
        return `rgb(${r},${g},${b})`;
      } else {
        // Extreme Rain: Red
        return `rgb(255,0,0)`;
      }
    }

    // ===== CLIP POLYGON LOADER =====
    let clipPolygon = null;

    async function loadClipPolygon() {
      try {
        const resp = await fetch("/static/outer_citanduy.geojson");
        if (!resp.ok) {
          console.warn("Could not load outer_citanduy.geojson");
          return;
        }

        const gj = await resp.json();
        if (!gj.features || !gj.features[0]) return;

        const geom = gj.features[0].geometry;

        if (geom.type === "Polygon") {
          clipPolygon = geom.coordinates[0];
        } else if (geom.type === "MultiPolygon") {
          // Find largest polygon
          let biggest = geom.coordinates[0][0];
          for (const poly of geom.coordinates) {
            if (poly[0].length > biggest.length) {
              biggest = poly[0];
            }
          }
          clipPolygon = biggest;
        }

        console.log("Clip polygon loaded:", clipPolygon?.length, "points");
      } catch (e) {
        console.error("Error loading clip polygon:", e);
      }
    }

    // ===== IDW CANVAS LAYER =====
    L.GridLayer.IDW = L.GridLayer.extend({
      options: {
        cellSize: 20,
        power: 2,
        opacity: 0.6
      },

      initialize: function(options) {
        L.setOptions(this, options);
        this._stations = [];
      },

      setStations: function(stations) {
        this._stations = stations;
        if (this._map) {
          this.redraw();
        }
      },

      createTile: function(coords) {
        // Create a canvas tile
        const tile = L.DomUtil.create('canvas', 'leaflet-tile');
        const size = this.getTileSize();
        tile.width = size.x;
        tile.height = size.y;

        // Only draw if we have stations
        if (this._stations.length === 0) {
          return tile;
        }

        const ctx = tile.getContext('2d');
        this._drawTile(tile, ctx, coords);
        
        return tile;
      },

      _drawTile: function(tile, ctx, coords) {
        const tileSize = this.getTileSize();
        const cellSize = this.options.cellSize;

        // Calculate tile bounds in lat/lng
        const nwPoint = coords.scaleBy(tileSize);
        const sePoint = nwPoint.add(tileSize);
        const nw = this._map.unproject(nwPoint, coords.z);
        const se = this._map.unproject(sePoint, coords.z);

        // Apply clipping if polygon exists
        if (clipPolygon && clipPolygon.length > 0) {
          ctx.save();
          ctx.beginPath();

          for (let i = 0; i < clipPolygon.length; i++) {
            const [lng, lat] = clipPolygon[i];
            const point = this._map.project([lat, lng], coords.z);
            const x = point.x - nwPoint.x;
            const y = point.y - nwPoint.y;

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }

          ctx.closePath();
          ctx.clip();
        }

        // Draw IDW grid
        const latStep = (se.lat - nw.lat) / (tileSize.y / cellSize);
        const lngStep = (se.lng - nw.lng) / (tileSize.x / cellSize);

        for (let y = 0; y < tileSize.y; y += cellSize) {
          for (let x = 0; x < tileSize.x; x += cellSize) {
            const lat = nw.lat + (y / tileSize.y) * (se.lat - nw.lat);
            const lng = nw.lng + (x / tileSize.x) * (se.lng - nw.lng);

            const value = this._calculateIDW(lat, lng);
            
            ctx.fillStyle = getColor(value);
            ctx.globalAlpha = this.options.opacity;
            ctx.fillRect(x, y, cellSize, cellSize);
          }
        }

        // Restore context if clipped
        if (clipPolygon) {
          ctx.restore();
        }
      },

      _calculateIDW: function(lat, lng) {
        if (this._stations.length === 0) return 0;

        let numerator = 0;
        let denominator = 0;

        for (const station of this._stations) {
          const dx = (station.lng - lng) * Math.cos(lat * Math.PI / 180);
          const dy = station.lat - lat;
          const dist = Math.sqrt(dx * dx + dy * dy) * 111000; // Approximate meters

          if (dist < 1) return station.rainfall;

          const weight = 1 / Math.pow(dist, this.options.power);
          numerator += weight * station.rainfall;
          denominator += weight;
        }

        return denominator > 0 ? numerator / denominator : 0;
      }
    });

    L.gridLayer.idw = function(opts) {
      return new L.GridLayer.IDW(opts);
    };

    // Create and add IDW layer
    const idwLayer = L.gridLayer.idw({
      cellSize: 20,
      power: 2,
      opacity: 0.6
    }).addTo(map);

    // ===== MARKERS LAYER =====
    const markersLayer = L.layerGroup().addTo(map);

    function updateMarkers(stations) {
      markersLayer.clearLayers();
      
      for (const s of stations) {
        L.circleMarker([s.lat, s.lng], {
          radius: 6,
          weight: 1,
          color: '#333',
          fillColor: getColor(s.rainfall),
          fillOpacity: 0.9
        })
        .bindPopup(`<b>Rainfall:</b> ${s.rainfall.toFixed(1)} mm`)
        .addTo(markersLayer);
      }
    }

    function fitBoundsToStations(stations) {
      if (stations.length === 0) return;
      
      const bounds = L.latLngBounds(stations.map(s => [s.lat, s.lng]));
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [30, 30] });
      }
    }

    // ===== DATA FETCHING =====
    async function fetchRainData() {
      const params = new URLSearchParams(window.location.search);
      const sampling = params.get('s');
      const url = '/api/rain' + (sampling ? `?s=${sampling}` : '');
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('Failed to fetch rain data');
      }
      
      return await response.json();
    }

    function processRainData(data) {
      console.log("Processing rain data:", data.items?.length || 0, "items");
      
      const stations = data.items
        .filter(item => item.pos && item.pos.latlon)
        .map(item => {
          const [lat, lng] = item.pos.latlon.split(',').map(parseFloat);
          const rainfall = parseFloat(item.telemetri?.rain24 ?? 0);
          
          return {
            lat: lat,
            lng: lng,
            rainfall: isNaN(rainfall) ? 0 : rainfall
          };
        });

      if (stations.length > 0) {
        // Update global min/max
        rainMin = Math.min(...stations.map(s => s.rainfall));
        rainMax = Math.max(...stations.map(s => s.rainfall));
        
        console.log("Rain range:", rainMin, "to", rainMax);
        console.log("Processed stations:", stations.length);
      }

      return stations;
    }

    function applyRainData(data) {
      const stations = processRainData(data);
      
      // Update IDW layer
      idwLayer.setStations(stations);
      
      // Update markers
      updateMarkers(stations);
      
      // Fit bounds on first load
      if (!window._initialBoundsFit && stations.length > 0) {
        fitBoundsToStations(stations);
        window._initialBoundsFit = true;
      }
    }

    // ===== INITIALIZATION =====
    async function initialize() {
      console.log("Initializing map...");
      
      // Add legend to map
      const legend = L.control({ position: 'bottomright' });
      
      legend.onAdd = function(map) {
        const div = L.DomUtil.create('div', 'legend');
        div.innerHTML = `
          <div style="margin-bottom: 8px; font-weight: bold;">Intensitas Hujan (mm)</div>
          <div><span class="colorbox" style="background: rgb(255,0,0);"></span> > 150 - Hujan Ekstrim</div>
          <div><span class="colorbox" style="background: rgb(255,100,0);"></span> 100 - 150 - Hujan Sangat Lebat</div>
          <div><span class="colorbox" style="background: rgb(255,165,0);"></span> 50 - 100 - Hujan Lebat</div>
          <div><span class="colorbox" style="background: rgb(255,255,0);"></span> 20 - 50 - Hujan Sedang</div>
          <div><span class="colorbox" style="background: rgb(72,190,0);"></span> 0.5 - 20 - Hujan Ringan</div>
          <div><span class="colorbox" style="background: rgba(0,0,0,0); border: 1px solid #ccc;"></span> < 0.5 - Tidak Ada Hujan</div>
        `;
        return div;
      };
      
      legend.addTo(map);
      
      try {
        // Load clip polygon (non-blocking)
        loadClipPolygon();
        
        // Fetch and apply rain data
        const rainData = await fetchRainData();
        applyRainData(rainData);
        
        // Set up auto-refresh every 2 minutes
        setInterval(async () => {
          try {
            const data = await fetchRainData();
            applyRainData(data);
            console.log("Data refreshed");
          } catch (e) {
            console.error("Refresh error:", e);
          }
        }, 120000);
        
      } catch (e) {
        console.error("Initialization error:", e);
      }
    }

    // Start the app
    initialize();
  </script>
</body>
</html>
{% endblock %}